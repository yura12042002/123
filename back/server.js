const TelegramBot = require("node-telegram-bot-api");
const {
  saveMessage,
  getMessagesByTelegramId,
} = require("./controllers/userController");
const express = require("express");
const dotenv = require("dotenv");
const connectDB = require("./conf/dataBase");
const mainPromt = require("./generalPromt");
const errorHandler = require("./middlewares/errorHandler");
const studentRoutes = require("./routes/studentRoutes");
const Student = require("./models/Student");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");

const cors = require("cors");

dotenv.config();
connectDB();

const app = express();

app.use(express.json()); // üëà –î–æ–ª–∂–Ω–∞ –±—ã—Ç—å –¥–æ app.post("/api/send-code")

app.use(cors());

app.use("/api/students", studentRoutes);

app.use(errorHandler);

const OpenAI = require("openai");
const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const bot = new TelegramBot(process.env.BOT_TOKEN_TURISM, { polling: true });
const botAuth = new TelegramBot(process.env.BOT_TOKEN_AUTHORIZE, {
  polling: true,
});

const adminId = process.env.ADMIN_TELEGRAM_ID;

app.post("/api/login", async (req, res) => {
  const { telegram, password } = req.body;

  if (!telegram || !password) {
    return res.status(400).json({ error: "–í—Å–µ –ø–æ–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã" });
  }

  try {
    const student = await Student.findOne({ telegram });

    if (!student) {
      return res.status(404).json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });
    }

    const isMatch = await bcrypt.compare(password, student.password);
    if (!isMatch) {
      return res.status(401).json({ error: "–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å" });
    }

    const token = jwt.sign(
      { id: student._id, telegram: student.telegram },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );

    res.json({
      success: true,
      token,
      student: {
        id: student._id,
        firstName: student.firstName,
        lastName: student.lastName,
        telegram: student.telegram,
        email: student.email,
      },
    });
  } catch (err) {
    return res.status(500).json({ error: "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞" });
  }
});

const pendingRegistrations = new Map(); // –≤—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ

app.post("/api/send-code", async (req, res) => {
  const studentData = req.body;

  if (!studentData.telegram) {
    return res.status(400).json({ error: "Telegram –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω" });
  }

  const requestId = Date.now().toString(); // —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID
  pendingRegistrations.set(requestId, studentData);

  const messageText = `
üë§ –ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é:

üë§ –ò–º—è: ${studentData.firstName}
üë§ –§–∞–º–∏–ª–∏—è: ${studentData.lastName}
üìÖ –í–æ–∑—Ä–∞—Å—Ç: ${studentData.age}
üìß Email: ${studentData.email}
üì® Telegram: ${studentData.telegram}

‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∏–ª–∏ ‚ùå –æ—Ç–∫–ª–æ–Ω–∏—Ç—å?
  `;

  botAuth.sendMessage(adminId, messageText, {
    reply_markup: {
      inline_keyboard: [
        [
          { text: "‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data: `approve_${requestId}` },
          { text: "‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data: `reject_${requestId}` },
        ],
      ],
    },
  });

  return res.json({ success: true });
});

app.get("/api/status/:telegram", async (req, res) => {
  try {
    const student = await Student.findOne({ telegram: req.params.telegram });

    if (!student) {
      return res.json({ status: "pending" });
    }

    return res.json({ status: "approved" });
  } catch (err) {
    return res.status(500).json({ error: "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞" });
  }
});

botAuth.on("callback_query", async (query) => {
  const chatId = query.message.chat.id;
  const data = query.data;
  const messageId = query.message.message_id;

  if (data.startsWith("approve_") || data.startsWith("reject_")) {
    const [action, requestId] = data.split("_");

    const studentData = pendingRegistrations.get(requestId);
    if (!studentData) {
      return botAuth.answerCallbackQuery(query.id, {
        text: "–ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω",
        show_alert: true,
      });
    }

    if (action === "approve") {
      try {
        const existing = await Student.findOne({
          telegram: studentData.telegram,
        });
        if (existing) {
          await botAuth.editMessageText(
            "‚ö†Ô∏è –≠—Ç–æ—Ç Telegram —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω",
            {
              chat_id: chatId,
              message_id: messageId,
            }
          );
          pendingRegistrations.delete(requestId);
          return;
        }

        const hashedPassword = await bcrypt.hash(studentData.password, 10);
        const student = new Student({
          ...studentData,
          password: hashedPassword,
        });
        await student.save();

        await botAuth.editMessageText(
          "‚úÖ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ –ë–î",
          {
            chat_id: chatId,
            message_id: messageId,
          }
        );

        pendingRegistrations.delete(requestId);
      } catch (err) {
        await botAuth.sendMessage(
          chatId,
          `‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏: ${err.message}`
        );
      }
    }

    if (action === "reject") {
      await botAuth.editMessageText("‚ùå –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞", {
        chat_id: chatId,
        message_id: messageId,
      });

      pendingRegistrations.delete(requestId);
    }

    return botAuth.answerCallbackQuery(query.id);
  }
});

bot.onText(/\/echo (.+)/, (msg, match) => {
  const chatId = msg.chat.id;
  const resp = match[1];

  bot.sendMessage(chatId, resp);
});

bot.on("message", async (msg) => {
  const chatId = msg.chat.id;
  const text = msg.text;

  await saveMessage(chatId, text, "user");

  const context = await getMessagesByTelegramId(chatId);

  const completion = await client.chat.completions.create({
    messages: [
      {
        role: "developer",
        content: mainPromt,
      },
      ...context.slice(-20),
      {
        role: "developer",
        content: `!!! –ü–∏—à–∏ –æ—Ç–≤–µ—Ç—ã –≤ json —Ñ–æ—Ä–º–∞—Ç–µ  —ç—Ç–æ –æ—á–µ–Ω—å –≤–∞–∂–Ω–æ :
{
        "textContent": "—Ç–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ",
        "buttons": [] // –º–∞—Å—Å–∏–≤ —Å—Ç—Ä–æ–∫ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–µ—Ç –Ω–∞–∂–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–∏—à–∏ –∏—Ö –æ—Ç—Ç–∞–ª–∫–∏–≤–∞—è—Å—å –æ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
}
!!! –ø—Ä–µ–¥–ª–∞–≥–∞–π –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–∞ —Ç–æ–ª—å–∫–æ —Ç–µ, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ —Ç—ã –∑–Ω–∞–µ—à—å –æ—Ç–≤–µ—Ç –∏–∑ —Ç–µ–∫—Å—Ç–∞, –µ—Å–ª–∏ –ø–æ–Ω–∏–º–∞–µ—à—å —á—Ç–æ –∫–ª–∏–µ–Ω—Ç –≥–æ—Ç–æ–≤ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å–≤ —Å–æ–æ–±—â–µ–Ω–∏–∏ –æ—Ç–¥–µ–ª—å–Ω–æ —É–∫–∞–∂–∏ —Å–ø–æ—Å–æ–± —Å–≤—è–∑–∏ —Å–æ –º–Ω–æ–π, —Å—Å—ã–ª–∫–∞ –Ω–∞ –º–æ–π —Ç–≥ - @yurasokol, —Ç–∞–∫–∂–µ –¥–æ–±–∞–≤–ª—è–π –ø—Ä–∏–∫–æ–ª—å–Ω—ã–µ —Å–º–∞–π–ª–∏–∫–∏ –∫ –∫–Ω–æ–ø–∫–∞–º –≤—ã—à–µ —ç—Ç–æ –æ—á–µ–Ω—å –≤–∞–∂–Ω–æ `,
      },
    ],
    model: "gpt-4.1",
    store: true,
  });

  const parseJSON = JSON.parse(completion.choices[0].message.content);

  if (parseJSON.buttons) {
    await saveMessage(
      chatId,
      completion.choices[0].message.content,
      "assistant"
    );

    const inlineKeyboard = parseJSON.buttons.map((btn) => [
      {
        text: btn,
        callback_data: btn.toLowerCase().replace(/\s+/g, "_").slice(0, 64),
      },
    ]);

    // –≤–∏—Å–ø–µ—Ä –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≥–æ–ª–æ—Å–∞ –≤ —Ç–µ–∫—Å—Ç

    bot.sendMessage(chatId, parseJSON.textContent, {
      reply_markup: {
        inline_keyboard: inlineKeyboard,
      },
    });
  } else {
    await saveMessage(
      chatId,
      completion.choices[0].message.content,
      "assistant"
    );
  }
});

bot.on("callback_query", async (query) => {
  const chatId = query.message.chat.id;
  const data = query.data;

  await saveMessage(chatId, data, "user");

  const context = await getMessagesByTelegramId(chatId);
  const completion = await client.chat.completions.create({
    messages: [
      {
        role: "developer",
        content: mainPromt,
      },
      ...context.slice(-20),
      {
        role: "developer",
        content: `!!! –ü–∏—à–∏ –æ—Ç–≤–µ—Ç—ã –≤ json —Ñ–æ—Ä–º–∞—Ç–µ  —ç—Ç–æ –æ—á–µ–Ω—å –≤–∞–∂–Ω–æ :
{
        "textContent": "—Ç–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ",
        "buttons": [] // –º–∞—Å—Å–∏–≤ —Å—Ç—Ä–æ–∫ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–µ—Ç –Ω–∞–∂–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–∏—à–∏ –∏—Ö –æ—Ç—Ç–∞–ª–∫–∏–≤–∞—è—Å—å –æ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
}
!!! –ø—Ä–µ–¥–ª–∞–≥–∞–π –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–∞ —Ç–æ–ª—å–∫–æ —Ç–µ, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–µ —Ç—ã –∑–Ω–∞–µ—à—å –æ—Ç–≤–µ—Ç –∏–∑ —Ç–µ–∫—Å—Ç–∞ –≤—ã—à–µ —ç—Ç–æ –æ—á–µ–Ω—å –≤–∞–∂–Ω–æ `,
      },
    ],
    model: "gpt-4.1",
  });

  console.log(completion.choices[0].message.content);

  const parsed = JSON.parse(completion.choices[0].message.content);
  const buttons = Array.isArray(parsed.buttons) ? parsed.buttons : [];

  const inlineKeyboard = buttons.map((btn) => [
    {
      text: btn,
      callback_data: btn.toLowerCase().replace(/\s+/g, "_").slice(0, 64),
    },
  ]);

  await saveMessage(chatId, parsed.textContent, "assistant");

  bot.sendMessage(chatId, parsed.textContent, {
    reply_markup: {
      inline_keyboard: inlineKeyboard,
    },
  });

  bot.answerCallbackQuery(query.id);
});

const pendingResets = new Map(); // email => —Å—Ç–∞—Ç—É—Å

app.post("/api/request-password-reset", async (req, res) => {
  const { telegram } = req.body;

  if (!telegram) return res.status(400).json({ error: "Telegram –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω" });

  const student = await Student.findOne({ telegram }); // ‚úÖ –ò—â–µ–º –ø–æ telegram
  if (!student)
    return res.status(404).json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });

  const resetId = Date.now().toString();
  pendingResets.set(resetId, { telegram, approved: false });

  const message = `üîÅ –ó–∞–ø—Ä–æ—Å –Ω–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞—Ä–æ–ª—è:
üì® Telegram: ${telegram}`;

  botAuth.sendMessage(adminId, message, {
    reply_markup: {
      inline_keyboard: [
        [{ text: "‚úÖ –û–¥–æ–±—Ä–∏—Ç—å", callback_data: `reset_approve_${resetId}` }],
      ],
    },
  });

  res.json({ success: true });
});

botAuth.on("callback_query", async (query) => {
  const data = query.data;

  if (data.startsWith("reset_approve_")) {
    const resetId = data.replace("reset_approve_", "");
    const request = pendingResets.get(resetId);

    if (!request) {
      return botAuth.answerCallbackQuery(query.id, {
        text: "–ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω",
        show_alert: true,
      });
    }

    request.approved = true;
    pendingResets.set(resetId, request);

    botAuth.editMessageText("‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Ä–∞–∑—Ä–µ—à–µ–Ω–æ —Å–º–µ–Ω–∏—Ç—å –ø–∞—Ä–æ–ª—å", {
      chat_id: query.message.chat.id,
      message_id: query.message.message_id,
    });

    return botAuth.answerCallbackQuery(query.id);
  }
});

app.get("/api/check-reset-status/:telegram", (req, res) => {
  const telegram = req.params.telegram;
  const entry = [...pendingResets.values()].find(
    (r) => r.telegram === telegram
  );
  if (!entry) return res.json({ status: "pending" });
  return res.json({ status: entry.approved ? "approved" : "pending" });
});

app.post("/api/confirm-new-password", async (req, res) => {
  const { telegram, newPassword } = req.body;

  const student = await Student.findOne({ telegram });
  if (!student)
    return res.status(404).json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });

  const hashed = await bcrypt.hash(newPassword, 10);
  student.password = hashed;
  await student.save();

  for (const [key, val] of pendingResets.entries()) {
    if (val.telegram === telegram) pendingResets.delete(key);
  }

  res.json({ success: true });
});

botAuth.on("message", async (msg) => {
  const chatId = msg.chat.id;
  const telegram = msg.from.username;

  await Student.updateOne({ telegram }, { chatId });

  bot.sendMessage(
    chatId,
    "‚úÖ –û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –Ω–∞ —Å–∞–π—Ç–µ"
  );
});

const loginCodes = new Map(); // telegram => { code, expires }

app.post("/api/request-login-code", async (req, res) => {
  const { telegram } = req.body;

  const student = await Student.findOne({ telegram });
  if (!student || !student.chatId)
    return res
      .status(404)
      .json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ —Å–≤—è–∑–∞–ª—Å—è —Å –±–æ—Ç–æ–º" });

  const code = Math.floor(100000 + Math.random() * 900000).toString();
  loginCodes.set(telegram, { code, expires: Date.now() + 5 * 60 * 1000 });

  await botAuth.sendMessage(student.chatId, `üîê –í–∞—à –∫–æ–¥ –¥–ª—è –≤—Ö–æ–¥–∞: ${code}`);

  return res.json({ success: true });
});

app.post("/api/verify-login-code", async (req, res) => {
  const { telegram, code } = req.body;
  const entry = loginCodes.get(telegram);

  if (!entry || entry.code !== code || Date.now() > entry.expires) {
    return res.status(401).json({ error: "–ù–µ–≤–µ—Ä–Ω—ã–π –∏–ª–∏ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–π –∫–æ–¥" });
  }

  const student = await Student.findOne({ telegram });
  if (!student) return res.status(404).json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });

  const token = jwt.sign(
    { id: student._id, telegram: student.telegram },
    process.env.JWT_SECRET
  );

  loginCodes.delete(telegram);

  res.json({
    success: true,
    token,
    student: {
      id: student._id,
      firstName: student.firstName,
      lastName: student.lastName,
      telegram: student.telegram,
      email: student.email,
    },
  });
});

// botAuth.on("message", async (msg) => {
//   const chatId = msg.chat.id;
//   const telegram = msg.from.username;
//   const text = msg.text;

//   // –°–æ—Ö—Ä–∞–Ω—è–µ–º chatId –ø—Ä–∏ –ø–µ—Ä–≤–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏
//   await Student.updateOne({ telegram }, { chatId });

//   // –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (–µ—Å–ª–∏ –Ω–æ–≤–æ–µ)
//   if (text === "/start") {
//     botAuth.sendMessage(chatId, "‚úÖ –í—ã —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å –∫ —Å–∏—Å—Ç–µ–º–µ! –¢–µ–ø–µ—Ä—å –º–æ–∂–µ—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –Ω–∞ —Å–∞–π—Ç–µ.");
//     return;
//   }

//   // ChatGPT —á–∞—Å—Ç—å
//   await saveMessage(chatId, text, "user");
//   const context = await getMessagesByTelegramId(chatId);

//   const completion = await client.chat.completions.create({
//     messages: [
//       { role: "developer", content: mainPromt },
//       ...context.slice(-20),
//       {
//         role: "developer",
//         content: `!!! –ü–∏—à–∏ –æ—Ç–≤–µ—Ç—ã –≤ json —Ñ–æ—Ä–º–∞—Ç–µ:
// {
//   "textContent": "—Ç–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ",
//   "buttons": []
// }`,
//       },
//     ],
//     model: "gpt-4.1",
//     store: true,
//   });

//   const parsed = JSON.parse(completion.choices[0].message.content);

//   await saveMessage(chatId, parsed.textContent, "assistant");

//   if (parsed.buttons?.length) {
//     const inlineKeyboard = parsed.buttons.map((btn) => [
//       {
//         text: btn,
//         callback_data: btn.toLowerCase().replace(/\s+/g, "_").slice(0, 64),
//       },
//     ]);
//     bot.sendMessage(chatId, parsed.textContent, {
//       reply_markup: { inline_keyboard: inlineKeyboard },
//     });
//   } else {
//     bot.sendMessage(chatId, parsed.textContent);
//   }
// });



const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  console.log(`!!! Server is running on http://localhost:${PORT}`);
});
